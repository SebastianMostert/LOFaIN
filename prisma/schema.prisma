// prisma/schema.prisma

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String          @id @default(auto()) @map("_id") @db.ObjectId
  name          String?
  email         String?         @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  Authenticator Authenticator[]
  discord       Json

  // Current assigned country
  countryId String?  @db.ObjectId
  country   Country? @relation(fields: [countryId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Vote      Vote[]
  Amendment Amendment[]
}

model Country {
  id       String  @id @default(auto()) @map("_id") @db.ObjectId
  name     String  @unique
  slug     String  @unique
  code     String? // e.g., "FRA", "USSR", "ITA"
  colorHex String? // muted accent for UI
  isActive Boolean @default(true)

  // Can they veto
  hasVeto Boolean @default(false)

  users    User[]
  mappings CountryMapping[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Vote      Vote[]
  Amendment Amendment[]
}

model CountryMapping {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  discordId String  @unique
  countryId String  @db.ObjectId
  country   Country @relation(fields: [countryId], references: [id])
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model Authenticator {
  credentialID         String  @id @map("_id")
  userId               String  @db.ObjectId
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, credentialID])
}

// Core treaty
model Treaty {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  title     String
  slug      String    @unique
  adopted   Boolean   @default(true)
  adoptedAt DateTime?
  preamble  String?
  articles  Article[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  Amendment Amendment[]
}

model Article {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  treatyId String @db.ObjectId
  order    Int
  heading  String
  body     String
  treaty   Treaty @relation(fields: [treatyId], references: [id], onDelete: Cascade)

  @@unique([treatyId, order])
}

// Amendments-only
enum AmendmentOp {
  ADD // add a new article (or new clause)
  EDIT // replace body/heading of an existing article
  REMOVE // remove an article
}

enum AmendmentStatus {
  DRAFT
  OPEN
  CLOSED
}

enum AmendmentResult {
  PASSED
  FAILED
}

model Amendment {
  id              String           @id @default(auto()) @map("_id") @db.ObjectId
  treatyId        String           @db.ObjectId
  // Target: if EDIT/REMOVE → target existing article; if ADD → can be null + newOrder provided
  targetArticleId String?          @db.ObjectId
  op              AmendmentOp
  slug            String           @unique // e.g., "amendment-1"
  title           String
  rationale       String? // explain why
  // Proposed content
  newHeading      String? // for ADD/EDIT
  newBody         String? // for ADD/EDIT
  newOrder        Int? // for ADD (where to insert)
  // Voting
  status          AmendmentStatus  @default(DRAFT)
  result          AmendmentResult?
  opensAt         DateTime?
  closesAt        DateTime?
  threshold       Float? // default 2/3 if null
  eligibleCount   Int? // frozen at OPEN time
  quorum          Int? @default(0) // minimum votes required
  votes           Vote[]

  treaty Treaty @relation(fields: [treatyId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  proposerCountryId String? @db.ObjectId
  proposerUserId    String? @db.ObjectId

  proposerCountry Country? @relation(fields: [proposerCountryId], references: [id], onDelete: SetNull)
  proposerUser    User?    @relation(fields: [proposerUserId], references: [id], onDelete: SetNull)

  // Reason for failure, if any
  failureReason String?
}

enum VoteChoice {
  AYE
  NAY
  ABSTAIN
  ABSENT
}

model Vote {
  id          String     @id @default(auto()) @map("_id") @db.ObjectId
  amendmentId String     @db.ObjectId
  countryId   String     @db.ObjectId
  userId      String?    @db.ObjectId
  choice      VoteChoice
  comment     String?
  createdAt   DateTime   @default(now())

  amendment Amendment @relation(fields: [amendmentId], references: [id], onDelete: Cascade)
  country   Country   @relation(fields: [countryId], references: [id], onDelete: Cascade)
  user      User?     @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([amendmentId, countryId]) // one vote per country per amendment
}
